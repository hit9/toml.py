Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYGROUP

Grammar

Rule 0     S' -> start
Rule 1     start -> translation_unit
Rule 2     translation_unit -> assignment
Rule 3     translation_unit -> translation_unit assignment
Rule 4     assignment -> KEY EQUALS value
Rule 5     value -> array
Rule 6     value -> DATETIME
Rule 7     value -> STRING
Rule 8     value -> FLOAT
Rule 9     value -> INTEGER
Rule 10    value -> BOOLEN
Rule 11    array -> [ sequence ]
Rule 12    sequence -> value
Rule 13    sequence -> sequence ,
Rule 14    sequence -> sequence , value

Terminals, with rules where they appear

,                    : 13 14
BOOLEN               : 10
DATETIME             : 6
EQUALS               : 4
FLOAT                : 8
INTEGER              : 9
KEY                  : 4
KEYGROUP             : 
STRING               : 7
[                    : 11
]                    : 11
error                : 

Nonterminals, with rules where they appear

array                : 5
assignment           : 2 3
sequence             : 11 13 14
start                : 0
translation_unit     : 1 3
value                : 4 12 14

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . translation_unit
    (2) translation_unit -> . assignment
    (3) translation_unit -> . translation_unit assignment
    (4) assignment -> . KEY EQUALS value

    KEY             shift and go to state 3

    start                          shift and go to state 2
    translation_unit               shift and go to state 4
    assignment                     shift and go to state 1

state 1

    (2) translation_unit -> assignment .

    KEY             reduce using rule 2 (translation_unit -> assignment .)
    $end            reduce using rule 2 (translation_unit -> assignment .)


state 2

    (0) S' -> start .



state 3

    (4) assignment -> KEY . EQUALS value

    EQUALS          shift and go to state 5


state 4

    (1) start -> translation_unit .
    (3) translation_unit -> translation_unit . assignment
    (4) assignment -> . KEY EQUALS value

    $end            reduce using rule 1 (start -> translation_unit .)
    KEY             shift and go to state 3

    assignment                     shift and go to state 6

state 5

    (4) assignment -> KEY EQUALS . value
    (5) value -> . array
    (6) value -> . DATETIME
    (7) value -> . STRING
    (8) value -> . FLOAT
    (9) value -> . INTEGER
    (10) value -> . BOOLEN
    (11) array -> . [ sequence ]

    DATETIME        shift and go to state 10
    STRING          shift and go to state 7
    FLOAT           shift and go to state 8
    INTEGER         shift and go to state 12
    BOOLEN          shift and go to state 11
    [               shift and go to state 14

    array                          shift and go to state 13
    value                          shift and go to state 9

state 6

    (3) translation_unit -> translation_unit assignment .

    KEY             reduce using rule 3 (translation_unit -> translation_unit assignment .)
    $end            reduce using rule 3 (translation_unit -> translation_unit assignment .)


state 7

    (7) value -> STRING .

    KEY             reduce using rule 7 (value -> STRING .)
    $end            reduce using rule 7 (value -> STRING .)
    ]               reduce using rule 7 (value -> STRING .)
    ,               reduce using rule 7 (value -> STRING .)


state 8

    (8) value -> FLOAT .

    KEY             reduce using rule 8 (value -> FLOAT .)
    $end            reduce using rule 8 (value -> FLOAT .)
    ]               reduce using rule 8 (value -> FLOAT .)
    ,               reduce using rule 8 (value -> FLOAT .)


state 9

    (4) assignment -> KEY EQUALS value .

    KEY             reduce using rule 4 (assignment -> KEY EQUALS value .)
    $end            reduce using rule 4 (assignment -> KEY EQUALS value .)


state 10

    (6) value -> DATETIME .

    KEY             reduce using rule 6 (value -> DATETIME .)
    $end            reduce using rule 6 (value -> DATETIME .)
    ]               reduce using rule 6 (value -> DATETIME .)
    ,               reduce using rule 6 (value -> DATETIME .)


state 11

    (10) value -> BOOLEN .

    KEY             reduce using rule 10 (value -> BOOLEN .)
    $end            reduce using rule 10 (value -> BOOLEN .)
    ]               reduce using rule 10 (value -> BOOLEN .)
    ,               reduce using rule 10 (value -> BOOLEN .)


state 12

    (9) value -> INTEGER .

    KEY             reduce using rule 9 (value -> INTEGER .)
    $end            reduce using rule 9 (value -> INTEGER .)
    ]               reduce using rule 9 (value -> INTEGER .)
    ,               reduce using rule 9 (value -> INTEGER .)


state 13

    (5) value -> array .

    KEY             reduce using rule 5 (value -> array .)
    $end            reduce using rule 5 (value -> array .)
    ]               reduce using rule 5 (value -> array .)
    ,               reduce using rule 5 (value -> array .)


state 14

    (11) array -> [ . sequence ]
    (12) sequence -> . value
    (13) sequence -> . sequence ,
    (14) sequence -> . sequence , value
    (5) value -> . array
    (6) value -> . DATETIME
    (7) value -> . STRING
    (8) value -> . FLOAT
    (9) value -> . INTEGER
    (10) value -> . BOOLEN
    (11) array -> . [ sequence ]

    DATETIME        shift and go to state 10
    STRING          shift and go to state 7
    FLOAT           shift and go to state 8
    INTEGER         shift and go to state 12
    BOOLEN          shift and go to state 11
    [               shift and go to state 14

    array                          shift and go to state 13
    value                          shift and go to state 16
    sequence                       shift and go to state 15

state 15

    (11) array -> [ sequence . ]
    (13) sequence -> sequence . ,
    (14) sequence -> sequence . , value

    ]               shift and go to state 17
    ,               shift and go to state 18


state 16

    (12) sequence -> value .

    ]               reduce using rule 12 (sequence -> value .)
    ,               reduce using rule 12 (sequence -> value .)


state 17

    (11) array -> [ sequence ] .

    ]               reduce using rule 11 (array -> [ sequence ] .)
    ,               reduce using rule 11 (array -> [ sequence ] .)
    KEY             reduce using rule 11 (array -> [ sequence ] .)
    $end            reduce using rule 11 (array -> [ sequence ] .)


state 18

    (13) sequence -> sequence , .
    (14) sequence -> sequence , . value
    (5) value -> . array
    (6) value -> . DATETIME
    (7) value -> . STRING
    (8) value -> . FLOAT
    (9) value -> . INTEGER
    (10) value -> . BOOLEN
    (11) array -> . [ sequence ]

    ]               reduce using rule 13 (sequence -> sequence , .)
    ,               reduce using rule 13 (sequence -> sequence , .)
    DATETIME        shift and go to state 10
    STRING          shift and go to state 7
    FLOAT           shift and go to state 8
    INTEGER         shift and go to state 12
    BOOLEN          shift and go to state 11
    [               shift and go to state 14

    array                          shift and go to state 13
    value                          shift and go to state 19

state 19

    (14) sequence -> sequence , value .

    ]               reduce using rule 14 (sequence -> sequence , value .)
    ,               reduce using rule 14 (sequence -> sequence , value .)

